const closeTemplate = {
  type: "block_close",
  tag: "div",
  attrs: null,
  map: null,
  nesting: -1,
  level: 0,
  children: null,
  content: "",
  markup: "",
  info: "",
  meta: null,
  block: true,
  hidden: false
};

// only available in opening tag, so it is cached for closing
let infoCache;

function before(tokens, idx, title) {
  const opening = `${
    tokens.firstSticky ? "" : "</div></div>"
  }<div class="sticky__container"><div><div class="sticky">`;
  if (tokens.firstSticky) {
    /**
     * to have wrapper sticky__container close right before next one opens.
     * if it is the first one, push a closing tag to the end of token stream,
     * if it is not the first, closing tag is prepended to opening, see above
     */
    tokens.firstSticky = false;
    tokens.push(closeTemplate, closeTemplate);
  }
  return opening;
}

function after(tokens, idx, title) {
  return `${title}</div></div><div>`;
}

export default function mdSticky(md, name, opts) {
  md.use(require("markdown-it-container"), "sticky", {
    render(tokens, idx) {
      // dirty hack to save state per tokenList
      if (typeof tokens.firstSticky === "undefined") {
        tokens.firstSticky = true;
      }
      const info = tokens[idx].info ? tokens[idx].info : infoCache;
      const title = info.replace(/^sticky(.*)$/, `$1`).trim();
      if (tokens[idx].nesting === 1) {
        infoCache = info;
        return before(tokens, idx, title);
      } else {
        return after(tokens, idx, title);
      }
    }
  });
}
